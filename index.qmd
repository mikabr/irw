---
title: "Item Response Warehouse"
subtitle: "The Item Response Warehouse (IRW) is a collection of open, harmonized item response datasets."
description: |  
  * Open: The data are licensed for reformatting and public reuse. Their provenance is documented and code used to transform original data to meet the IRW data standard is available.
  
  * Harmonized: The data are formatted to a common standard. The goal of the IRW is to make large quantities of data available for standardized analysis given the common formatting. 
  
  * Item Response: The IRW is comprised of cross-classified item responses. The key element required of data for inclusion in the IRW is that the data need to report individual responses that are cross-classified by the focus of measurement (typically a person) and the measurement tool (typically an item).
  
  These datasets in IRW span a wide range of measures; examples include measures of ability in education settings, measures of partisanship based on voting records, and personality measures based on survey questions.  Responses can be scored in a variety of ways (dichotomous, polytomous, continuous) and may contain additional data (e.g., response time).

title-block-banner: "#2780e3"
title-block-banner-color: white
---

{{< include _load-data.qmd >}}

{{< include components/_interval.qmd >}}
{{< include components/_hist.qmd >}}
{{< include components/_tol.qmd >}}

```{ojs prelims}
// import newer version of observable plot than the one embedded in quarto 
Plot = import("https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm")

md = transpose(datasets)
md
//mda = md.map(obj => Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, Array.isArray(value) ? value : [value]])))
//mda
```


{{< include components/_style.qmd >}}

```{ojs info}
// info for numeric variables
vi = ({
  "n_responses":               { label: "Number responses",          base: 10 },
  "n_categories":              { label: "Number categories",         base:  2 },
  "n_participants":            { label: "Number participants",       base: 10 },
  "n_items":                   { label: "Number items",              base: 10 },
  "responses_per_participant": { label: "Responses per participant", base: 10 },
  "responses_per_item":        { label: "Responses per item",        base: 10 },
  "density":                   { label: "Density",                   base: 10 }
})

// info for tag variables
ti = ({
  "age_range":                             { label: "Age range"                             } ,
  "child_age__for_child_focused_studies_": { label: "Child age (for child-focused studies)" } ,
  "construct_type":                        { label: "Construct type"                        } ,
  "sample":                                { label: "Sample"                                } ,
  "measurement_tool":                      { label: "Measurement tool"                      } ,
  "item_format":                           { label: "Item format"                           } ,
  "primary_language_s_":                   { label: "Primary language(s)"                   } ,
  "license":                               { label: "License"                               } ,
})
```

```{ojs filter-funs}
// formatting function for how two ended slider displays selected range
// (use SI prefix if base 10 otherwise  default format)
pow_format = (v, b) => b === 10 ? d3.format("~s")(Math.pow(b, v)) : Plot.formatNumber("en-US")(Math.pow(b, v))
interval_format = (b) => ([start, end]) => `[${pow_format(start, b)}; ${pow_format(end, b)}]`

// any base log
log = (x, b) => Math.log(x) / Math.log(b)
// log-transformed extent of array of values
log_range = (x, b) => [Math.floor(log(d3.min(x), b)), Math.ceil(log(d3.max(x), b))]

// interval input for a given numeric variable
var_interval = (v) => {
  return interval(log_range(md.map(d => d[v]), vi[v].base), {
    step: 1, label: vi[v].label, format: interval_format(vi[v].base), width: "95%"
  })
}

// checkbox input for a given tag variable
tag_checkbox = (t) => Inputs.checkbox(tags[t], {label: ti[t].label, value: tags[t]})
```

:::::: {.column-screen-inset}
::::: {layout="[ [19,55,26] ]"}

:::: {.panel-input}

_Filter by quantitative properties._

::: {.side-inputs}

::: {.filters-container}

```{ojs filter-responses}
viewof n_responses_range = var_interval("n_responses")
```

```{ojs filter-categories}
viewof n_categories_range = var_interval("n_categories")
```

```{ojs filter-participants}
viewof n_participants_range = var_interval("n_participants")
```

```{ojs filter-items}
viewof n_items_range = var_interval("n_items")
```

```{ojs filter-responses-per-participant}
viewof responses_per_participant_range = var_interval("responses_per_participant")
```

```{ojs filter-responses-per-item}
viewof responses_per_item_range = var_interval("responses_per_item")
```

```{ojs filter-density}
viewof density_range = var_interval("density")
```

:::
:::

-----

_Filter by variables._

::: {.side-inputs}

::: {.filters-container}

```{ojs filter-variable}
viewof variable = Inputs.select(vars.variable, {
  label: "Variable", multiple: true, value: vars.variable
})
```

```{ojs filter-prefix}
viewof prefix = Inputs.select(vars.prefix, {
  label: "Variable prefix", multiple: true, value: vars.prefix
})
```

```{ojs filter-longitudinal}
viewof longitudinal = Inputs.checkbox(vars.longitudinal, {
  label: "Longitudinality", value: vars.longitudinal
})
```

:::
:::

::::

:::: {.panel-fill}

```{ojs data-filtered}
// generate range filter function for a given numeric variable and input range
range_filter = (v, v_range) => {
  return (d) => d[v] >= Math.pow(vi[v].base, v_range[0]) &
                d[v] <= Math.pow(vi[v].base, v_range[1])
}

// array of range filter functions for all numeric variables
range_filters = ([
  range_filter( "n_responses",               n_responses_range               ),
  range_filter( "n_categories",              n_categories_range              ),
  range_filter( "n_participants",            n_participants_range            ),
  range_filter( "n_items",                   n_items_range                   ),
  range_filter( "responses_per_participant", responses_per_participant_range ),
  range_filter( "responses_per_item",        responses_per_item_range        ),
  range_filter( "density",                   density_range                   ),
])

// generate overlap filter function for a given categorical variable and input values
overlap_filter = (t, t_vals) => {
  return (d) => t_vals.some(v => d[t].includes(v))
}

// array of overlap filter functions for all categorical variables
overlap_filters = ([
  overlap_filter( "age_range",                             age_range_vals        ),
  overlap_filter( "child_age__for_child_focused_studies_", child_age_vals        ),
  overlap_filter( "construct_type",                        construct_type_vals   ),
  overlap_filter( "sample",                                sample_vals           ),
  overlap_filter( "measurement_tool",                      measurement_tool_vals ),
  overlap_filter( "item_format",                           item_format_vals      ),
  overlap_filter( "primary_language_s_",                   primary_language_vals ),
  overlap_filter( "license",                               license_vals          ),
  overlap_filter( "variable",                              variable              ),
  overlap_filter( "prefix",                                prefix                ),
  overlap_filter( "longitudinal",                          longitudinal          ),
])

// apply all range filters and overlap filters to metadata
all_filters = [...range_filters, ...overlap_filters]
ds = all_filters.reduce((mdf, fun) => mdf.filter(fun), md)
```

::: {.plot-container}
::: {.plot-inputs}

```{ojs x-var}
num_vars = new Map(Object.entries(vi).map(([key, value]) => [value.label, key]))
viewof x_var = Inputs.select(num_vars, {value: "n_items", label: "X axis"})
```

```{ojs y-var}
viewof y_var = Inputs.select(num_vars, {value: "n_participants", label: "Y axis"})
```

```{ojs color-var}
//cat_array = Object.entries(ti).map(([key, value]) => [value.label, key])
cat_array = color_vars.map((t) => [ti[t].label, t])
cat_vars = new Map([["None", null], ...cat_array])
viewof color_var = Inputs.select(cat_vars, {label: "Color"})
```

:::

```{ojs scatter}
// define color for plot content: color_var if set, otherwise default_color
default_color = "grey"

// construct object of all variables to be tip channels
// table = ({table: {label: "table"}})
// channels = Object.fromEntries(Object.entries({...table, ...vi, ...ti}).map(([key, value]) => [key, key]))

// given array of strings or single string, collapses to one comma separated string
stringify = (x) => {
  const ax = Array.isArray(x) ? x : [x]
  return ax.join(", ")
}

// scatter plot
Plot.plot({
  x: {type: "log", base: vi[x_var].base},
  y: {type: "log", base: vi[y_var].base},
  width: 700,
  grid: true,
  color: {range: tol.QualMuted, legend: color_var != null},
  marks: [
    // points
    Plot.dot(ds, {
      x: x_var,
      y: y_var,
      stroke: (d) => stringify(d[color_var])
    }),
    // regression line
    Plot.linearRegressionY(ds, {
      x: x_var,
      y: y_var,
      stroke: (d) => stringify(d[color_var])
    }),
    // tooltips
    Plot.tip(ds, Plot.pointer({
      x: x_var,
      y: y_var,
      stroke: (d) => stringify(d[color_var]),
      title: "table",
      // channels: channels
    }))
  ]
})
```
:::

```{ojs result-message}
html`<p><i>Filtered to ${ds.length} datasets out of ${md.length} total.</i></p>`
```

```{ojs table}
// sparkbar element generator given max value and log base
sparkbar = (max, b) => {
  return x => htl.html`<div class="sparkbar" style="width: ${100 * log(x, b) / log(max, b)}%;">${x.toLocaleString("en")}`
}

// sparkbar element generator for a given numeric variable
var_sparkbar = (v) => sparkbar(d3.max(ds, d => d[v]), vi[v].base)

// sparkbars for each numeric variable
sparks = Object.fromEntries(Object.entries(vi).map(([key, value]) => [key, var_sparkbar(key)]))

// inline histogram element given array of values and header string
inlinehist = (vals, head) => {
  return htl.html`<span class="hist">${hist(vals)}${head}</span>`
}

// inline histogram for a given numeric variable
var_hist = (v) => inlinehist(ds.map(d => log(d[v], vi[v].base)), v)

// histograms for each numeric variable
hists = Object.fromEntries(Object.entries(vi).map(([key, value]) => [key, var_hist(key)]))

// data table for selected tables
Inputs.table(ds, {
  rows: 20,
  sort: "n_responses", reverse: true,
  // show columns "table", all numeric variables, and all tag variables
  columns: ["table", ...num_vars.values(), ...cat_vars.values()],
  // use inline histograms in header
  header: hists,
  // use sparkbars in cells
  format: sparks
})
```

::::

:::: {.panel-input}

_Filter by qualitative features._

::: {.side-inputs}

::: {.filters-container}

```{ojs filter-age-range}
viewof age_range_vals = tag_checkbox("age_range")
```

```{ojs filter-child-age}
viewof child_age_vals = tag_checkbox("child_age__for_child_focused_studies_")
```

```{ojs filter-construct-type}
viewof construct_type_vals = tag_checkbox("construct_type")
```

```{ojs filter-sample}
viewof sample_vals = tag_checkbox("sample")
```

```{ojs filter-measurement-tool}
viewof measurement_tool_vals = tag_checkbox("measurement_tool")
```

```{ojs filter-item-format}
viewof item_format_vals = tag_checkbox("item_format")
```

```{ojs filter-primary-language}
viewof primary_language_vals = tag_checkbox("primary_language_s_")
```

```{ojs filter-license}
viewof license_vals = tag_checkbox("license")
```

:::
:::
::::

:::::
::::::
